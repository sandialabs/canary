# Prototype Session Workflow Demo

This document outlines steps for trying the "session" workflow prototyped by @tjfulle.
The idea behind this workflow is that the list of tests are set and associated with a "tag" that simplifies management
of test results directories, re-execution, etc.

Please note that the prototype is **not** feature complete, and we are seeking feedback on whether we are headed in a useful
direction before pursuing further.

## Installation (dev branch, editable)
This workflow is under active development on the branch `tjfulle/repo-layout`.
For this reason, we advise cloning the branch and installing `canary` in editable mode to support pulling in updates without re-installation.
Instructions for this installation process are listed below. Note that `canary` requires python>=3.10.
```console
git clone --branch=tjfulle/repo-layout https://github.com/sandialabs/canary
cd canary
python3 -m venv venv && source venv/bin/activate
pip install -e .
```

## Session Concepts
The prototype introduces some new concepts to the `canary` execution workflow:
  1. initialization
  2. staging
  3. execution

### Initialization
<!-- canary init -h -->
```console
canary init [-h] [path]

Initialize a Canary session

positional arguments:
  path        Initialize session in this directory [default: $(pwd)]
```
The new initialization step establishes the working location for all subsequent `canary` commands and supports execution from anywhere below the specified `path`.
Once a session is initialized, test generator `pathspecs` can be added with `canary add` as described below:
<!-- canary add -h -->
```console
canary add [-h] pathspec [pathspec ...]

Add test generators to Canary session

positional arguments:
  pathspec    Add test generators found in pathspec to Canary session
```
Note that the `add` command does not take filtering arguments. Filtering is performed as part of session staging steps described in the next session.

### Staging
<!-- canary stage -h -->
```console
canary stage [-h] [-k expression] [-o option] [-p expression] [--search regex] [--rerun-failed] tag

Generate test cases for the given selection criteria and store the selection for later running

positional arguments:
  tag                   Tag this selection with TAG

options:
  -h, --help            Show this help message and exit.

filtering:
  -k expression         Only run tests matching given keyword expression. For example: `-k 'key1 and not key2'`. The keyword ``:all:`` matches all tests
  -o option             Turn option(s) on, such as '-o dbg' or '-o intel'
  -p expression         Filter tests by parameter name and value, such as '-p cpus=8' or '-p cpus<8'
  --search regex, --regex regex
                        Include tests containing the regular expression regex in at least 1 of its file assets. regex is a python regular expression, see https://docs.python.org/3/library/re.html
  --rerun-failed        Rerun failed tests [default: False]
...
```
The **optional** `stage` step(s) apply filters to create named test sets and generate the test case lock-files used by the execution phase.
If `canary stage` is not invoked within a session, the first invocation of `canary run` will generate a `default` tag associated with all test cases and execute them.

> **Note**: This step was previously performed by each invocation of `canary run`, whereas in the new workflow the lock files are cached between runs and only re-generated by `canary run` if the set of generators in the session changes

When additional `pathspec`(s) are added to the session (via `canary add`), the selection criteria are re-applied to the enlarged test set upon regeneration of test case lock files (either explicitly with `canary stage` or implicitly via `canary run [tag]`).

### Test Execution
```console
canary run [TAG]
```
Under the session workflow, all test selection is intended to be done via `stage` and associated with named sets.

> **Request for feedback**: What workflows need to be supported additionally? For example:
>  * running a specific test name/sha?
>  * filtering within a tag?

Contrary to the current default behavior of `canary run` outside the session workflow, the full set of tests associated with the tag are executed on each invocation in separate directory trees.
The `TestResults` directory is updated to point to the latest results directory in the internal datastore.

## End-to-End Walkthrough
This section contains an end-to-end demonstration of the "session" workflow leveraging the `canary` tests/examples for input.
If you are following along, the expectation is that the canary repository is at the tip of the development branch and the root of the project is the starting working directory.

### A first example
We begin by initializing and inspecting a session.
```console
$ canary init
version: 25.11.3+4667fcaa
==> Initialized empty canary session created at /.../canary/.canary
$ canary info
Test sessions repository: /.../canary/.canary
Version:       25.11.3+4667fcaa
Generators:    0
Sessions:      0
Latest:        None
Tags:
$ canary status
ID  Name  Session  Exit Code  Duration  Status  Details
==  ====  =======  =========  ========  ======  =======

```
The `init` subcommand creates a session in the current working directory and reports the path to the session.
`canary info` now reports the session information: location, number of generators, number of sessions/executions, the latest session/execution, and the list of tags.
As we can see, all of these values are zero/empty.
Finally `canary status` shows that there are no tests in the session.

Adding the `examples/basic` directory to the session adds generators, but does not yet generate tests as shown by the empty status.
```console
$ canary add examples
==> Searching examples for test generators... done (0.07s.)
==> Added 2 new test case generators to /.../.canary
$ canary status
ID  Name  Session  Exit Code  Duration  Status  Details
==  ====  =======  =========  ========  ======  =======

```

Executing `canary run` without any staging creates the `default` tag and runs all tests.
```console
$ canary run
version: 25.11.3+4667fcaa
==> Creating default case selection
==> Generating test cases... done (0.17s.)
==> Generated 2 test cases from 2 generators
==> Resolving test case dependencies... done (0.00s.)
==> Masking test cases based on filtering criteria... done (0.10s.)
==> Selected 2 test cases based on filtering criteria
==> Running 2 jobs
...
âš¡âš¡ Session done -- 2 total, 2 pass in 00:00:00.00
```
Note that the execution began by creating the "default" test case selection, then generated the test cases.
Invoking `canary run` again, skips these steps and runs all of the cases again.
```console
version: 25.11.3+4667fcaa
==> Running 2 jobs
...
âœ¨âœ¨ Session done -- 2 total, 2 pass in 00:00:01.00
```
We can now see some more details in the session's info:
```console
$ canary info
Test sessions repository: /.../canary/.canary
Version:       25.11.3+8b06d977
Generators:    2
Sessions:      2
Latest:        2025-11-03T14-03-21
Tags:          default
```
As mentioned, the `default` tag has been created, and we have executed 2 sessions.
The status is updated to list details of the test cases:
```console
$ canary status
ID       Name    Session                     Exit Code  Duration  Status   Details
=======  ======  ==========================  =========  ========  =======  =======
254b775  first   2025-11-03T14-03-21.433176  0          1.0       success  
96fb33c  second  2025-11-03T14-03-21.433176  0          1.0       success  
```
This status represents *all* test cases in the session, not only those included by the latest invocation of `canary run`, e.g., if a tag representing a subset was specified.

We've now demonstrated the workflow for starting a session, adding tests, and executing them. In the next section, we
demonstrate how to expand the test set and "stage" test cases.

### Expanding the test set
In this section, we add `pathspec`s to the session to increase the test of tests and demonstrate the re-generation of the test cases.
We add the `examples` directory (which includes the previous set of tests, but it could be different) and examine the info/status.
```console
$ canary add examples
==> Searching examples for test generators... done (0.07s.)
==> Warning: Invalidated previously locked test case cache
==> Warning: Test case generator already in repo (PYTTestGenerator(basic/first/first.pyt))
==> Warning: Test case generator already in repo (PYTTestGenerator(basic/second/second.pyt))
==> Added 36 new test case generators to /.../canary/.canary
$ canary info
Test sessions repository: /.../canary/.canary
Version:       25.11.3+8b06d977
Generators:    38
Sessions:      2
Latest:        2025-11-03T14-03-21
Tags:          default
```
Here, we see that `canary` detected that the test case cache has been invalidated and that there are some duplicate generators that are already in the session repo.
36 new generators are added to the session and this is reported by `info`.

We can regenerate the `default` test case cache/lock files and see the new test cases that are created.
```console
$ canary stage default
==> Generating test cases... done (0.11s.)
==> Generated 84 test cases from 38 generators
==> Resolving test case dependencies... done (0.00s.)
==> Masking test cases based on filtering criteria... done (0.12s.)
==> Selected 78 test cases based on filtering criteria
==> To run this collection of test cases, execute 'canary run default'

$ canary status
ID       Name                                    Session                     Exit Code  Duration  Status   Details
=======  ======================================  ==========================  =========  ========  =======  =======
d328b06  a                                       None                        NA         NA        created  
7f814d8  analyze_only                            None                        NA         NA        created  
5a00423  analyze_only[a=1,b=2,cpus=1]            None                        NA         NA        created  
6aff2fa  analyze_only[a=1,b=2,cpus=2]            None                        NA         NA        created 
...
254b775  first                                   2025-11-03T14-03-21.433176  0          1.0       success  
96fb33c  second                                  2025-11-03T14-03-21.433176  0          1.0       success  
```
Note there are now many tests with status `created` that have not been run in the session.

We can run the `default` selection again and examine the status again.
```console
$ canary run
version: 25.11.3+8b06d977
==> Running 78 jobs
...
ðŸ’¥ðŸ’¥ Session done -- 78 total, 67 pass, 2 xfail, 1 xdiff, 1 skipped, 1 diff, 4 fail, 2 timeout in 00:00:13
```
Note that there was no test case generation as the cache was already up to date. The session status is updated and shows
that there remain some tests that still have not run.
```console
$ canary status
ID       Name                                    Session                     Exit Code  Duration  Status   Details
=======  ======================================  ==========================  =========  ========  =======  ==========================================
30bc0af  enable                                  None                        NA         NA        created  
b066c7a  resource_group_test_1[cpus=2,gpus=2]    None                        NA         NA        created  
eccf7e9  resource_group_test_2[cpus=2,gpus=2]    None                        NA         NA        created  
ab7d00d  resources[cpus=1,gpus=1]                None                        NA         NA        created  
56852ee  resources[cpus=1000,gpus=1000]          None                        NA         NA        created  
e40c89f  resources[cpus=4,gpus=4]                None                        NA         NA        created
...
```
These tests did not run because their resource or other requirements were not met (i.e., `enable` requires a command line option, and the demo machine does not have any GPU resources).

We've now demonstrated how an existing test session can be expanded and the behavior of the `stage` command. In the next
section, we demonstrate using `stage` to partition test cases into selection sets that can be executed via `canary run`.

### Refining test sets
Now let's consider the case where we'd like to partition tests into parallel vs. serial sets.
This is achieved by calling `stage` as follows:
```console
$ canary stage -p 'cpus=1' serial
==> Generating test cases... done (0.18s.)
==> Generated 84 test cases from 38 generators
==> Resolving test case dependencies... done (0.00s.)
==> Masking test cases based on filtering criteria... done (0.12s.)
==> Selected 64 test cases based on filtering criteria
==> To run this collection of test cases, execute 'canary run serial'

$ canary stage -p 'cpus>1' parallel
==> Generating test cases... done (0.07s.)
==> Generated 84 test cases from 38 generators
==> Resolving test case dependencies... done (0.00s.)
==> Masking test cases based on filtering criteria... done (0.04s.)
==> Selected 13 test cases based on filtering criteria
==> To run this collection of test cases, execute 'canary run parallel'
```
Then calling `canary info` shows that there are now three tags:
```console
$ canary info
...
Tags:          default parallel serial
```

We can now run the parallel tests only by
```console
$ canary run parallel
version: 25.11.3+4667fcaa
==> Running 13 jobs
...
ðŸ’¥ðŸ’¥ Session done -- 13 total, 13 pass in 00:00:02
```
Note that only the 13 parallel tests were executed, and there was no test case generation step.
The session status is also updated
```console
$ canary status
ID       Name                                    Session                     Exit Code  Duration  Status   Details
=======  ======================================  ==========================  =========  ========  =======  ==========================================
...
51c3025  copy_and_link                           2025-11-03T13-14-57.774557  0          4.0       success  
bc54752  ctest_test                              2025-11-03T13-14-57.774557  0          0.0       success  
109eeba  depends_on_a                            2025-11-03T13-14-57.774557  0          2.0       success
...
333d31e  parameterize4[a=1,b=100000,cpus=4]      2025-11-03T13-35-32.135241  0          2.0       success  
e3f786e  parameterize4[a=1,b=100000,cpus=8]      2025-11-03T13-35-32.135241  0          2.0       success  
b5fc32b  parameterize4[a=2,b=1e+06,cpus=4]       2025-11-03T13-35-32.135241  0          2.0       success 
...
```
Note the different session identifiers for the serial tests (first block) compared to the parallel tests (second block).
If new generators are included in the session via the `canary add` subcommand, then these test case selections apply to
that increased set. As mentioned before, the test case selection can be explicitly re-constructed by the `stage` subcommand
or automatically regenerated/cached via `canary run`.

## Summary
We've demonstrated the prototype workflow, and by following this the user should understand the following:
  * initialization of a Canary session
  * addition of test generators by pathspec
  * optional creation of test sets via selection criteria applied to the session's test generators
  * execution and inspection of test results

If we proceed with development of this workflow, we intend to maintain legacy behavior of `canary run [options] pathspecs`;
however, a warning message with instructions on how to convert to the new workflow may be emitted (what would you want?).

This prototype workflow is not yet feature complete, and we desire feedback to identify if we are headed in a useful direction
for the increasingly diverse Canary user community. Some potential areas for feedback/direction:
  * naming conventions -- is `Sessions` in the `canary info` the right name, or is there something more clear
  * how would you want to navigate between prior sessions? How important of a use-case is this for us to consider?
  * how should report generation behave (not functional in the prototype)? Should the report be generated for the complete set of latest results, or only the latest session?
  * anything else you can think of!
